'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/workshops/tas/docs/kubernetes_basics/','title':"Kubernetes Basics",'content':""});index.add({'id':1,'href':'/workshops/tas/docs/environment_setup/','title':"Environment Setup",'content':"Environment Setup Account set up  Access to Pivotal Web Services  Target the Environment If you haven’t already, download the latest 0.6 release of the Cloud Foundry CLI from https://github.com/cloudfoundry/cli/releases for your operating system and install it.\nNOTE: The Tanzu Application Service is not currently compatible with the latest 7.0 version of the cf cli. Please download the latest release of version 6.  Login to Pivotal Cloud Foundry and follow the prompts\n$ cf login -a https://api.run.pivotal.io\nApps Manager UI  An alternative to installing the CF CLI is via your PCF Apps Manager interface. Navigate in a web browser to https://console.run.pivotal.io Click the Tools link, and download the CLI matching your operating system  "});index.add({'id':2,'href':'/workshops/tas/docs/cloudfoundry/','title':"Pushing to Cloud Foundry",'content':"Pushing to Cloud Foundry Push It! Clone or download the repo into a path Spring Music :\n$ cd $WORKSHOP_HOME/spring-music  Push the application!\n$ cf push  You should see output similar to the following listing. Language specific output has been omitted for clarity. Take a look at the listing callouts for a play-by-play of what’s happening:\nUsing manifest file /Users/phopper/workspace/NBCU-PCF-Workshop-101/cf-spring-mvc-boot/manifest.yml Creating app workshop in org TELCO / space hopper as phopper@pivotal.io... OK Creating route workshop-philologic-catchpolery.vert.fe.gopivotal.com... OK Binding workshop-philologic-catchpolery.vert.fe.gopivotal.com to workshop... OK Uploading workshop... Uploading app files from: /Users/phopper/workspace/NBCU-PCF-Workshop-101/cf-spring-mvc-boot/target/cf-spring-mvc-boot-0.0.1-SNAPSHOT.jar Uploading 10.6M, 153 files Done uploading OK Starting app workshop in org TELCO / space hopper as phopper@pivotal.io... -----\u0026gt; Downloaded app package (27M) -----\u0026gt; Java Buildpack Version: v3.1.1 (offline) | https://github.com/cloudfoundry/java-buildpack#7a538fb -----\u0026gt; Downloading Open Jdk JRE 1.8.0_51 from https://download.run.pivotal.io/openjdk/trusty/x86_64/openjdk-1.8.0_51.tar.gz (found in cache) Expanding Open Jdk JRE to .java-buildpack/open_jdk_jre (1.5s) -----\u0026gt; Downloading Open JDK Like Memory Calculator 1.1.1_RELEASE from https://download.run.pivotal.io/memory-calculator/trusty/x86_64/memory-calculator-1.1.1_RELEASE (found in cache) Memory Settings: -Xss995K -Xmx382293K -Xms382293K -XX:MaxMetaspaceSize=64M -XX:MetaspaceSize=64M -----\u0026gt; Downloading Spring Auto Reconfiguration 1.7.0_RELEASE from https://download.run.pivotal.io/auto-reconfiguration/auto-reconfiguration-1.7.0_RELEASE.jar (found in cache) -----\u0026gt; Uploading droplet (72M) 0 of 1 instances running, 1 starting 0 of 1 instances running, 1 starting 1 of 1 instances running App started OK App workshop was started using this command `CALCULATED_MEMORY=$($PWD/.java-buildpack/open_jdk_jre/bin/java-buildpack-memory-calculator-1.1.1_RELEASE -memorySizes=metaspace:64m.. -memoryWeights=heap:75,metaspace:10,stack:5,native:10 -totMemory=$MEMORY_LIMIT) \u0026amp;\u0026amp; SERVER_PORT=$PORT $PWD/.java-buildpack/open_jdk_jre/bin/java -cp $PWD/.:$PWD/.java-buildpack/spring_auto_reconfiguration/spring_auto_reconfiguration-1.7.0_RELEASE.jar -Djava.io.tmpdir=$TMPDIR -XX:OnOutOfMemoryError=$PWD/.java-buildpack/open_jdk_jre/bin/killjava.sh $CALCULATED_MEMORY -Djava.security.egd=file:///dev/urandom org.springframework.boot.loader.JarLauncher` Showing health and status for app workshop in org TELCO / space hopper as phopper@pivotal.io... OK requested state: started instances: 1/1 usage: 512M x 1 instances urls: workshop-philologic-catchpolery.vert.fe.gopivotal.com last uploaded: Thu Sep 24 20:15:27 UTC 2015 stack: cflinuxfs2 buildpack: java-buildpack=v3.1.1-offline-https://github.com/cloudfoundry/java-buildpack#7a538fb java-main java-opts open-jdk-like-jre=1.8.0_51 open-jdk-like-memory-calculator=1.1.1_RELEASE spring-auto-reconfiguration=1.7.0_RELEASE state since cpu memory disk details #0 running 2015-09-24 02:16:11 PM 2.4% 392.6M of 512M 151.6M of 1G  The CLI is using a manifest to provide necessary configuration details such as application name, memory to be allocated, and path to the application artifact. Take a look at manifest.yml to see how.\nIn most cases, the CLI indicates each Cloud Foundry API call as it happens. In this case, the CLI has created an application record for Workshop in your assigned space.\nAll HTTP/HTTPS requests to applications will flow through Cloud Foundry’s front-end router called (Go)Router. Here the CLI is creating a route with random word tokens inserted (again, see manifest.yml for a hint!) to prevent route collisions across the default domain.\nNow the CLI is binding the created route to the application. Routes can actually be bound to multiple applications to support techniques such as blue-green deployments.\nThe CLI finally uploads the application bits to Pivotal Cloudfoundry. Notice that it’s uploading 75 files! This is because Cloud Foundry actually explodes a ZIP artifact before uploading it for caching purposes.\nNow we begin the staging process. The Java Buildpack is responsible for assembling the runtime components necessary to run the application.\nHere we see the version of the JRE that has been chosen and installed.\nThe complete package of your application and all of its necessary runtime components is called a droplet. Here the droplet is being uploaded to Pivotal Cloudfoundry’s internal blobstore so that it can be easily copied to one or more Droplet Execution Agents (DEA’s) for execution.\nThe CLI tells you exactly what command and argument set was used to start your application.\nFinally the CLI reports the current status of your application’s health.\nVisit the application in your browser by hitting the route that was generated by the CLI:\nInteract with App from CF CLI Get information about the currently deployed application using CLI apps command:\n$ cf apps  Note the application name for next steps\nGet information about running instances, memory, CPU, and other statistics using CLI instances command\n$ cf app \u0026lt;\u0026lt;app_name\u0026gt;\u0026gt;  Stop the deployed application using the CLI\n$ cf stop \u0026lt;\u0026lt;app_name\u0026gt;\u0026gt;  Delete the deployed application using the CLI\n$ cf delete \u0026lt;\u0026lt;app_name\u0026gt;\u0026gt;  Congratulations! You have pushed your first app into Cloud Foundry! On to the next Lab!\n"});index.add({'id':3,'href':'/workshops/tas/docs/services/','title':"Binding Cloudfoundry Services",'content':"Binding Cloudfoundry Services The Workshop application was designed to illustrate the ease with which data services can be bound to and utilized by applications running on Cloud Foundry. In this lab, we’ll be binding the application to a Postgres databases.\nCloud Foundry services are managed through two primary types of operations:\nCreate/Delete\n These operations create or delete instances of a service. For a database this could mean creating/deleting a schema in an existing multitenant cluster or creating/deleting a dedicated database cluster.  Bind/Unbind\n These operations create or delete unique credential sets for an existing service instance that can then be injected into the environment of an application instance.  A Bit of Review Your instance of the sample sping-music should not be running after the steps completed in the previous lab. Make sure to change to the spring-music application directory. For this lab we will be using the Java application. Redeploy the application:\n $ cf push  After the application deploys and starts, visit the application in your browser by hitting the route that was generated by the CLI. Currently, this data is being retrieved from an in-memory HSQL database\nThe Services Marketplace There are two ways to discover what services are available on Pivotal Platform. The first is available on any instance of Cloud Foundry: the CLI. Just type:\n $ cf marketplace  and you’ll get a list of services, their available plans, and descriptions. On Pivotal Platform, the “free” tier of plans is normally the first one listed.\nThe second way is specific to Pivotal Platform’s Apps Manager UI. If you haven’t already, login to it by visiting https://{your_org_pcf_api_endpoint}\nClick on the ‘Marketplace’ link and you’ll see the same service/plan/description listing in the browser:\nCreating and Binding to a Service Instance Let’s begin by creating a Postgres service instance. From the Apps Manager UI service marketplace, select ElephantSQL for Pivotal Platform, select the tiny turtle plan, and provide an instance name. In the drop-down list next to Bind to App select your spring-music application.\nNotice the admonition to Use \u0026lsquo;cf restage\u0026rsquo; to ensure your env variable changes take effect. Let’s take a look at the environment variables for our application. We can do this by viewing to the homepage of the application. Here we will see a printout of the environment information. Take note of what is contained in the section Bound Services. It’s an empty JSON document!\nNow let’s restage the application, which cycles our application back through the staging/buildpack process before redeploying the application. (In this case, we could accomplish the same goal by only restarting the application via cf restart spring-music. A restage is generally recommended because Cloud Foundry buildpacks also have access to injected environment variables and can install or configure things differently based on their values.)\n $ cf restage spring-music  Once the application is running again, revisit or refresh the browser tab where you have the Wokshop application loaded. You’ll notice now we have information that could be used to connect to a DB. In fact, our data is now being retrieved from that Postgres database!\n\u0026quot;VCAP_SERVICES\u0026quot;: { \u0026quot;p-mysql\u0026quot;:[ { \u0026quot;name\u0026quot;:\u0026quot;adam-db\u0026quot;, \u0026quot;label\u0026quot;:\u0026quot;p-mysql\u0026quot;, \u0026quot;tags\u0026quot;:[ \u0026quot;mysql\u0026quot;, \u0026quot;relational\u0026quot; ], \u0026quot;plan\u0026quot;:\u0026quot;100mb\u0026quot;, \u0026quot;credentials\u0026quot;:{ \u0026quot;hostname\u0026quot;:\u0026quot;10.68.105.55\u0026quot;, \u0026quot;port\u0026quot;:3306, \u0026quot;name\u0026quot;:\u0026quot;cf_226845a3_1982_44ac_92b9_4b149af56bbc\u0026quot;, \u0026quot;username\u0026quot;:\u0026quot;n67hpBOnKlsPUjKn\u0026quot;, \u0026quot;password\u0026quot;:\u0026quot;hUa4WSrq2hPtBsuk\u0026quot;, \u0026quot;uri\u0026quot;:\u0026quot;mysql://n67hpBOnKlsPUjKn:hUa4WSrq2hPtBsuk@10.68.105.55:3306/cf_226845a3_1982_44ac_92b9_4b149af56bbc?reconnect=true\u0026quot;, \u0026quot;jdbcUrl\u0026quot;:\u0026quot;jdbc:mysql://10.68.105.55:3306/cf_226845a3_1982_44ac_92b9_4b149af56bbc?user=n67hpBOnKlsPUjKn\u0026amp;password=hUa4WSrq2hPtBsuk\u0026quot; } } ] }  You may also verify your service was provisioned in the Apps Manager UI by clicking on your application and selecting the Services tab.\nYou should now see the service created in step 1 listed.\nYou may also verify your service was provisioned using the CLI:\n$ cf services  You should now see the service created in step 1 listed and your application listed as a bound app.\nCongratulations! You have just bound your first Cloud Foundry Service!\n"});index.add({'id':4,'href':'/workshops/tas/docs/operating_your_application/','title':"Operating Your Application",'content':"Operating your application Pivotal Cloudfoundry makes the work of performing operations actions, such as scaling, doing a zero-downtime deploy, and managing application health very easy. In the next two labs we’ll explore Pivotal Cloudfoundry operations.\nScale the Application Up Now let’s increase the number of running application instances to 3. In each of the commands below replace workshop with the name of your deployed application:\n$ cf scale -i 3 workshop Scaling app workshop in org DEMO / space gammon as nsterling@pivotal.io... OK  In reporting OK, the CLI is letting you know that the additional requested instances have been started, but they are not yet necessarily running.\nWe can determine how many instances are actually running like this:\n$ cf app workshop Showing health and status for app workshop in org DEMO / space gammon as nsterling@pivotal.io... OK requested state: started instances: 1/3 usage: 512M x 3 instances urls: workshop.vert.fe.gopivotal.com, workshop-queasier-backup.vert.fe.gopivotal.com last uploaded: Fri Aug 7 13:15:14 UTC 2015 stack: cflinuxfs3 state since cpu memory disk details #0 running 2015-08-07 11:33:21 AM 0.1% 477.9M of 512M 144.4M of 1G #1 starting 2015-08-07 12:42:56 PM 0.0% 0 of 0 0 of 0 #2 starting 2015-08-07 12:42:56 PM 0.0% 0 of 0 0 of 0 This application instance has completed the startup process and is actually able to accept requests. This application instance is still starting and will not have any requests routed to it.  Eventually all instances will converge to a running state:\n$ cf app workshop Showing health and status for app workshop in org DEMO / space gammon as nsterling@pivotal.io... OK requested state: started instances: 3/3 usage: 512M x 3 instances urls: workshop.vert.fe.gopivotal.com, workshop-queasier-backup.vert.fe.gopivotal.com last uploaded: Fri Aug 7 13:15:14 UTC 2015 stack: cflinuxfs3 state since cpu memory disk details #0 running 2015-08-07 11:33:21 AM 0.1% 477.9M of 512M 144.4M of 1G #1 running 2015-08-07 12:43:04 PM 0.2% 396.2M of 512M 144.4M of 1G #2 running 2015-08-07 12:43:04 PM 0.2% 394.8M of 512M 144.4M of 1G  Revisit the application route in the browser. Refresh several times. You should observe the instance index changing as you do so:\nThe aforementioned (Go)Router is applying a random routing algorithm to all of the application instances assigned to this route. As an instance reaches the running state, its Diego Cell registers that instance in the routing table assigned to its route by sending a message to Cloud Foundry’s message bus. All (Go)Router instances are subscribed to this channel and register the routes independently. This makes for very dynamic and rapid reconfiguration!\nScale the Application Down We can scale the application instances back down as easily as we scaled them up, using the same command structure:\n$ cf scale -i 1 workshop Scaling app workshop in org DEMO / space gammon as nsterling@pivotal.io... OK  Check the application status again:\n$ cf app workshop Showing health and status for app workshop in org DEMO / space gammon as nsterling@pivotal.io... OK requested state: started instances: 1/1 usage: 512M x 1 instances urls: workshop.vert.fe.gopivotal.com, workshop-queasier-backup.vert.fe.gopivotal.com last uploaded: Fri Aug 7 13:15:14 UTC 2015 stack: cflinuxfs3 buildpack: php-buildpack=v3.0-offline-https://github.com/cloudfoundry/php-buildpack.git#3bd15e1 open-jdk-jre=1.8.0_40 spring-auto-reconfiguration=1.7.0_RELEASE tomcat-access-logging-support=2.4.0_RELEASE tomcat-instance=8.0.21 tomcat-lifecycle-support=2.4.0_REL... state since cpu memory disk details #0 running 2015-08-07 11:33:21 AM 0.1% 477.9M of 512M 144.4M of 1G  As you can see, we’re back down to only one instance running, and it is in fact the original index 0 that we started with.\nConfirm that by again revisiting the route in the browser and checking the instance index:\nHTTP Routing\nThere are two ways to discover what routes, or HTTP URLs, are mapped to an application The first is available via the CLI. Just type:\n$ cf app workshop Showing health and status for app workshop in org DEMO / space DEMO as you@email.com... OK requested state: started instances: 3/3 usage: 512M x 3 instances urls: workshop-leishmanial-preobligation.vert.fe.gopivotal.com last uploaded: Fri Sep 25 15:07:25 UTC 2015 stack: cflinuxfs3 state since cpu memory disk details #0 running 2015-09-25 11:11:33 AM 0.1% 411.6M of 512M 151.6M of 1G  and you’ll see the list of routes in the section that says urls.\nThe second way is via the Apps Manager UI. Click on the Workshop application to view application details. Select the Routes tab to view a list of mapped routes:\nWe can easily add an additional route by clicking on + Map a Route and supplying the new hostname:\nNavigate to the new URL in your browser window. You should see that same application displayed!\nWe can just as easily remove a route by clicking on Unmap on the route you wish to remove.\nIf you navigate to that URL you’ll receive a HTTP 404 response\nThis is how blue-green deployments are accomplished.\nAccessing Container Contents SSH into your app container via cf ssh APP_NAME\nReference: https://docs.pivotal.io/pivotalcf/customizing/diego-ssh/access-apps.html\n"});index.add({'id':5,'href':'/workshops/tas/docs/monitoring_your_application/','title':"Monitoring Your Application",'content':"Monitoring your application Pivotal Cloudfoundry makes the work of performing operations actions, such as scaling, doing a zero-downtime deploy, and managing application health very easy. In the this labs we’ll continue to explore Pivotal Cloudfoundry application operations.\nApplication Container and Network Monitoring with PCF Metrics PCF Metrics helps developers better understand the health and performance of their apps by providing a near real-time view of critical data. Developers can see performance issues within two to three seconds, learn about events like an app crash as they occur, and look back in time to see what happened while they were away.\nFor developers, there’s nothing to install or configure, just select an app and watch the data stream.\nPCF Metrics provides the following data on app health and performance\n  Container metrics: CPU, memory, and disk percentages (updated every 30 seconds)\n  HTTP metrics: requests per second, HTTP errors per second, and request latency (updated every second)\n  App events: create, update, start, stop, and crash (updated as they happen)\n  Tailing Application Logs One of the most important enablers of visibility into application behavior is logging. Effective management of logs has historically been very difficult. Cloud Foundry’s log aggregation components simplify log management by assuming responsibility for it. Application developers need only log all messages to either STDOUT or STDERR, and the platform will capture these messages.\nFor Developers Application developers can view application logs using the CF CLI.\nLet’s view recent log messages for the application. In each of the commands below replace workshop with the name of your deployed application:\n$ cf logs workshop --recent  Here are two interesting subsets of one output from that command:\n2015-02-13T14:45:39.40-0600 [RTR/0] OUT cf-scale-boot-stockinged-rust.cfapps.io - [13/02/2015:20:45:39 +0000] \u0026quot;GET /css/bootstrap.min.css HTTP/1.1\u0026quot; 304 0 \u0026quot;http://cf-scale-boot-stockinged-rust.cfapps.io/\u0026quot; \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.111 Safari/537.36\u0026quot; 10.10.66.88:50372 x_forwarded_for:\u0026quot;50.157.39.197\u0026quot; vcap_request_id:84cc1b7a-bb30-4355-7512-5adaf36ff767 response_time:0.013115764 app_id:7a428901-1691-4cce-b7f6-62d186c5cb55 2015-02-13T14:45:39.40-0600 [RTR/1] OUT cf-scale-boot-stockinged-rust.cfapps.io - [13/02/2015:20:45:39 +0000] \u0026quot;GET /img/LOGO_CloudFoundry_Large.png HTTP/1.1\u0026quot; 304 0 \u0026quot;http://cf-scale-boot-stockinged-rust.cfapps.io/\u0026quot; \u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.111 Safari/537.36\u0026quot; 10.10.66.88:24323 x_forwarded_for:\u0026quot;50.157.39.197\u0026quot; vcap_request_id:b3e2466b-6a41-4c6d-5b3d-0f70702c0ec1 response_time:0.010003444 app_id:7a428901-1691-4cce-b7f6-62d186c5cb55 2015-02-13T15:04:33.09-0600 [API/1] OUT Tried to stop app that never received a start event 2015-02-13T15:04:33.51-0600 [DEA/12] OUT Starting app instance (index 2) with guid 7a428901-1691-4cce-b7f6-62d186c5cb55 2015-02-13T15:04:33.71-0600 [DEA/4] OUT Starting app instance (index 3) with guid 7a428901-1691-4cce-b7f6-62d186c5cb55 An “Apache-style” access log event from the (Go)Router An API log event that corresponds to an event as shown in cf events A DEA log event indicating the start of an application instance on that DEA. 2015-02-13T16:01:50.28-0600 [App/0] OUT 2015-02-13 22:01:50.282 INFO 36 --- [ runner-0] o.s.b.a.e.jmx.EndpointMBeanExporter : Located managed bean 'autoConfigurationAuditEndpoint': registering with JMX server as MBean [org.springframework.boot:type=Endpoint,name=autoConfigurationAuditEndpoint] 2015-02-13T16:01:50.28-0600 [App/0] OUT 2015-02-13 22:01:50.287 INFO 36 --- [ runner-0] o.s.b.a.e.jmx.EndpointMBeanExporter : Located managed bean 'shutdownEndpoint': registering with JMX server as MBean [org.springframework.boot:type=Endpoint,name=shutdownEndpoint] 2015-02-13T16:01:50.29-0600 [App/0] OUT 2015-02-13 22:01:50.299 INFO 36 --- [ runner-0] o.s.b.a.e.jmx.EndpointMBeanExporter : Located managed bean 'configurationPropertiesReportEndpoint': registering with JMX server as MBean [org.springframework.boot:type=Endpoint,name=configurationPropertiesReportEndpoint] 2015-02-13T16:01:50.36-0600 [App/0] OUT 2015-02-13 22:01:50.359 INFO 36 --- [ runner-0] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 61316/http 2015-02-13T16:01:50.36-0600 [App/0] OUT Started... 2015-02-13T16:01:50.36-0600 [App/0] OUT 2015-02-13 22:01:50.364 INFO 36 --- [ runner-0] o.s.boot.SpringApplication : Started application in 6.906 seconds (JVM running for 15.65)  As you can see, Cloud Foundry’s log aggregation components capture both application logs and CF component logs relevant to your application. These events are properly interleaved based on time, giving you an accurate picture of events as they transpired across the system.\nTo get a running “tail” of the application logs rather than a dump, simply type(replace workshop with the name of your deployed application):\n$ cf logs workshop  You can try various things like refreshing the browser and triggering stop/start events to see logs being generated.\nViewing Application Events Cloud Foundry only allows application configuration to be modified via its API. This gives application operators confidence that all changes to application configuration are known and auditable. It also reduces the number of causes that must be considered when problems arise.\nAll application configuration changes are recorded as events. These events can be viewed via the Cloud Foundry API, and viewing is facilitated via the CLI.\nTake a look at the events that have transpired so far for our deployment of workshop:\n $ cf events workshop Getting events for app workshop in org TELCO / space gammon as admin... time event actor description 2015-08-11T08:58:57.00-0400 app.crash workshop index: 0, reason: CRASHED, exit_description: app instance exited, exit_status: 255 2015-08-11T08:58:17.00-0400 audit.app.update admin instances: 5 2015-08-11T08:58:11.00-0400 audit.app.update admin 2015-08-11T08:58:11.00-0400 audit.app.map-route admin 2015-08-11T08:54:35.00-0400 audit.app.update admin state: STARTED 2015-08-11T08:54:22.00-0400 audit.app.update admin 2015-08-11T08:54:22.00-0400 audit.app.map-route admin 2015-08-11T08:54:19.00-0400 audit.app.create admin instances: 1, memory: 512, state: STOPPED, environment_json: PRIVATE DATA HIDDEN    Events are sorted newest to oldest, so we’ll start from the bottom. Here we see the app.create event, which created our application’s record and stored all of its metadata (e.g. memory: 512).\n  The app.map-route event records the incoming request to assign a route to our application.\n  This app.update event records the resulting change to our applications metadata.\n  This app.update event records the change of our application’s state to STARTED.\n  Remember scaling the application up? This app.update event records the metadata change instances: 5.\n  And here’s the app.crash event recording that we encountered a crash of an application instance.\n  Let’s explicitly ask for the application to be stopped:\n$ cf stop workshop Stopping app workshop in org TELCO / space gammon as admin... OK  Now, examine the additional app.update event:\n$ cf events workshop Getting events for app workshop in org TELCO / space gammon as admin... time event actor description 2015-08-11T09:01:35.00-0400 audit.app.update admin state: STOPPED 2015-08-11T08:58:57.00-0400 app.crash workshop index: 0, reason: CRASHED, exit_description: app instance exited, exit_status: 255 2015-08-11T08:58:17.00-0400 audit.app.update admin instances: 5 2015-08-11T08:58:11.00-0400 audit.app.update admin 2015-08-11T08:58:11.00-0400 audit.app.map-route admin 2015-08-11T08:54:35.00-0400 audit.app.update admin state: STARTED 2015-08-11T08:54:22.00-0400 audit.app.update admin 2015-08-11T08:54:22.00-0400 audit.app.map-route admin 2015-08-11T08:54:19.00-0400 audit.app.create admin instances: 1, memory: 512, state: STOPPED, environment_json: PRIVATE DATA HIDDEN  Start the application again:\n$ cf start workshop Starting app workshop in org TELCO / space gammon as admin... 0 of 5 instances running, 5 starting 2 of 5 instances running, 3 starting App started Showing health and status for app workshop in org TELCO / space gammon as admin... OK requested state: started instances: 5/5 usage: 512M x 5 instances urls: workshop-subhepatic-retiredness.vert.fe.gopivotal.com, adam-app.vert.fe.gopivotal.com last uploaded: Tue Aug 11 12:54:33 UTC 2015 stack: cflinuxfs3 state since cpu memory disk details #0 starting 2015-08-11 09:02:17 AM 0.0% 435.6M of 512M 144.4M of 1G #1 running 2015-08-11 09:02:26 AM 0.0% 406.3M of 512M 144.4M of 1G #2 running 2015-08-11 09:02:27 AM 0.0% 401.2M of 512M 144.4M of 1G #3 running 2015-08-11 09:02:26 AM 0.0% 403.9M of 512M 144.4M of 1G #4 starting 2015-08-11 09:02:17 AM 0.0% 398.2M of 512M 144.4M of 1G  And again, view the additional app.update event:\n$ cf events workshop Getting events for app workshop in org TELCO / space gammon as admin... time event actor description 2015-08-11T09:02:17.00-0400 audit.app.update admin state: STARTED 2015-08-11T09:01:35.00-0400 audit.app.update admin state: STOPPED 2015-08-11T08:58:57.00-0400 app.crash workshop index: 0, reason: CRASHED, exit_description: app instance exited, exit_status: 255 2015-08-11T08:58:17.00-0400 audit.app.update admin instances: 5 2015-08-11T08:58:11.00-0400 audit.app.update admin 2015-08-11T08:58:11.00-0400 audit.app.map-route admin 2015-08-11T08:54:35.00-0400 audit.app.update admin state: STARTED 2015-08-11T08:54:22.00-0400 audit.app.update admin 2015-08-11T08:54:22.00-0400 audit.app.map-route admin 2015-08-11T08:54:19.00-0400 audit.app.create admin instances: 1, memory: 512, state: STOPPED, environment_json: PRIVATE DATA HIDDEN  On to the next Lab!\n"});index.add({'id':6,'href':'/workshops/tas/docs/networking_and_policies/','title':"Networking \u0026 Policies (Advanced)",'content':"Networking \u0026amp; Policies (Advanced) Target the Environment This example demonstrates communication (HTTP and UDP) between a frontend and backend applications using service discovery over the container network.\n  Follow the earlier instructions to Get Environment Access\n  Clone or download the repo into a path CF Networking Examples :\n  Frontend The frontend allows you to test out container network communication via two methods:\n Connect to the backend via HTTP Connect to the backend via UDP  In either case, the response from the backend to the frontend will be rendered as a web page.\nDeploying  $ cd frontend $ cf push frontend  Use Case: Frontend Connects to Backend\nBackend The backend will be pushed with no external route and therefore should not be accessible via the public internet.\nBackend serves a picture of a typing cat on the TCP ports specified in the environment variable CATS_PORTS, and responds to simple text messages on the UDP ports specified in the environment variable UDP_PORTS.\nWe will give the backend an internal hostname that will map to the app’s container ips and can be used to connect via container-to-container networking. An internal hostname is configured via the CF CLI map-route command, with the domain provided set to the reserved internal domain of apps.internal.\nDeploying Backend (example with internal route defined in app manifest)\n $ cd $DIR/backend $ cf push backend --no-start $ cf set-env backend CATS_PORTS \u0026quot;7007,7008\u0026quot; $ cf set-env backend UDP_PORTS \u0026quot;9003,9004\u0026quot; $ cf start backend  Usage\nAfter both frontend and backend apps have been deployed, you can visit the frontend URL in a browser. You should see something like:\n Frontend Sample App HTTP Test Backend HTTP URL: [....] [ Submit ] UDP Test Backend UDP Server Address: [....] Message: [....] [ Submit ]  Usage with HTTP In the frontend app, in the Backend HTTP URL field enter backend’s internal hostname and a cats port (backend.apps.internal:7007). Hit submit.\nYou will see an error message saying the connection is refused. This is because the two apps have not been configured to allow connections from the frontend to the backend.\nIf you see an error message saying no such host, service discovery is incorrectly configured.\nNow allow access:\n cf add-network-policy frontend --destination-app backend --port 7007 --protocol tcp  Now if you try again from the frontend:\n[GIF OF CAT] Hello from the backend, port: 7007  Doing the same thing with backend-b should result in a different cat (specifically, a party cat) being shown.\nUsage with UDP In the frontend app, in the Backend UDP Server Address field, enter the backend’s internal hostname and UDP port (backend.apps.internal:9003) and a message. Hit submit.\nYou will see an error message. This is because the two apps have not been configured to allow connections from the frontend to the backend.\nNow allow access:\n cf add-network-policy frontend --destination-app backend --port 9003 --protocol udp  Now if you try again from the frontend:\n You sent the message: hello world Backend UDP server replied: HELLO WORLD  "});index.add({'id':7,'href':'/workshops/tas/docs/data_management/','title':"Data Management (Advanced)",'content':"Data Management (Advanced) Writing Files to local file system is a Cloud Native anti-pattern, but sometimes you just got to for any number of reasons.\n Tanzu Data Management\n"});index.add({'id':8,'href':'/workshops/tas/docs/security/','title':"Security Documentation (Advanced)",'content':"Security Documentation PWS implements the following measures to mitigate against security threats:\n Minimizes network surface area Isolates customer apps and data in containers Encrypts connections Uses role-based access controls, applying and enforcing roles and permissions to ensure that users can only view and affect the spaces for which they have been granted access Ensures security of app bits in a multi-tenant environment Prevents possible denial of service attacks through resource starvation  For more details please see the security documentation: Security Documentation\n"});index.add({'id':9,'href':'/workshops/tas/docs/troubleshooting/','title':"Troubleshooting App Development \u0026 Health (Advanced)",'content':"Troubleshooting App Development \u0026amp; Health (Advanced) For common troubleshooting tips please visit this documentation:\n Troubleshooting App Development \u0026amp; Health\n"});index.add({'id':10,'href':'/workshops/tas/docs/','title':"Docs",'content':""});})();